% Realizado por Martin Cordischi
% Para Computación Paralela y Distribuida
% UNICEN 2013
\documentclass[12pt,a4paper,oneside,spanish]{report}
\usepackage{amstext}
%Comandos extras de matematica
\usepackage{mathtools}
% Paquete para anadir codigo
\usepackage{listings}
% Paquete para traducir a esp los textos automagicos
\usepackage[spanish]{babel}
\selectlanguage{spanish}
% Paquete para frames
\usepackage{framed}
% Paquete grafico
\usepackage{graphicx}
%pseudocodigo
\usepackage{algpseudocode}
\usepackage{algorithm}
\usepackage{makeidx}
%Fancy headers
\usepackage{fancyhdr}
%Encoding con tildes
\usepackage[utf8]{inputenc}

% Encabezados
%\title{}
%\author{}
%\date{}
%\maketitle
% Fin encabezados
%\makeindex


%Header and footer
\thispagestyle{empty}
\renewcommand{\headrulewidth}{0.0pt}
\pagestyle{fancy}
\lhead{}
\chead{}
\rhead{}
\lfoot[]{}
\chead[]{}
\rfoot[]{}

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
\begin{document}

\begin{titlepage}
\begin{center}

% Upper part of the page. The '~' is needed because \\
% only works if a paragraph has started.
%\includegraphics[width=0.5\textwidth]{cuys.eps}~\\[1cm]

\textsc{\LARGE UNICEN}\\[1.5cm]



% Title
\HRule \\[0.4cm]
{ \huge \bfseries Copay-di}\\[0.4cm]

\HRule \\[0.4cm]

% Author and supervisor

\begin{center}
\textbf{}
\end{center}
~\\[3.5cm]


\textit{}


~\\[0.4cm]
\textit{} \textbf{} 

\vfill

% Bottom of the page
{\large \textbf{UNICEN} - Junio 2013}

\end{center}
\end{titlepage}

\chapter*{Resumen}

Como trabajo final de la cátedra de Computación Paralela y Distribuida, se ha realizado un sistema distribuido para el procesamiento de tareas de cualquier tipo sin dependencia entre ellas. Este framework desarrollado podrá ser utilizado para la realización de sistemas grid, dejando transparente todo el trabajo necesario para conexión de nodos, interacción entre ellos, y ejecución de tareas.

Este informe dará las nociones generales del sistema, notificará las principales decisiones adoptadas y detallará los elementos de interés para el funcionamiento de éste.



\chapter*{Introducción}

\chapter*{Desarrollo}

\subsection*{Nociones generales del sistema}

El objetivo principal del trabajo es la posibilidad de brindar procesamiento distribuido a tareas no dependientes a través de un sistema no centralizado, utilizando un modelo productor/consumidor. Como requerimiento funcional también se ha solicitado la posibilidad de establecer políticas de robo de trabajos entre los nodos consumidores.

Para llegar a cumplir los requerimientos, se ha desarrollado una aplicación en Java\ref{Java} la cual es capaz de recibir y ejecutar tareas brindadas por el usuario a través de una interfaz sencilla, utilizando la potencia del procesamiento distribuido.

El sistema desarrollado utiliza las facilidades brindadas por la biblioteca JGroups\ref{JGroups} para abstracción de la comunicación entre nodos. Esta herramienta ha traído importantes ventajas para la correcta implementación y ha satisfecho completamente la necesidad de tener un módulo de comunicación.

\subsection*{Características técnicas}

\begin{itemize}
	\item \textbf{Tipo de sistema:} Framework.
	\item \textbf{Propósito:} Procesamiento distribuido de tareas.
    \item \textbf{Lenguaje:} Java\ref{Java}.
    	\item \textbf{Bibliotecas externas:} Jgroups\ref{JGroups}.
%   	\item \textbf{Licencia:} 
\end{itemize}

\subsection*{Descripción del sistema}

El sistema se puede descomponer en 3 tipos de componentes principales:

\begin{itemize}
	\item \textbf{Nodos:} principales componentes del sistema, encargados de la conexión, la ejecución de tareas y la interacción con el usuario. Forman en conjunto un cluster.
	\item \textbf{Tareas:} elementos que se sirven de entrada y salida al sistema.
	\item \textbf{Mensajes:} componente completamente interno, encargados de contener la información transmitida entre los nodos.
\end{itemize}

Estos 3 tipos de componentes definen el sistema. Como soporte a ellos, también se definen

\begin{itemize}
	\item \textbf{Políticas:} empaquetadas en elementos del sistema sirven para determinar comportamientos de programación (scheduling) y de robos.
	\item \textbf{Eventos:} notifaciones de los nodos.
\end{itemize}

A continuación, se detallarán los elementos principales del sistema y sus funciones.

\subsubsection*{Nodos}
\label{sec:nodos}

%TODO Diagrama de componentes

Como se puede observar en \ref{fig:componentes}, los nodos son los elementos con mayores responsabilidades ya que deben establecer comunicaciones con otros nodos, seguir el estado del cluster y insertar y/o ejecutar tareas. Los nodos pueden corresponderse uno a uno con máquinas en un cluster, pero es necesario destacar que pueden existir y convivir más de un nodo por terminal, siendo así el caso en el que se desee procesar, insertar y/o monitorear tareas, teniendo un tipo de nodo distinto por propósito.

El sistema define 4 tipos de nodos, mostrados en \ref{fig:interfacesNodos}, los cuales están implementadas a través de la jerarquía de clases mostrada en \ref{fig:clasesNodos}. La funcionalidad principal de cada tipo de nodo es:

\begin{itemize}
	\item \textbf{Master:} Encargado de insertar tareas al cluster, este tipo de nodo devuelve resultados mediante la interfaz \textit{Future}, siendo así necesaria su conexión con el cluster siempre que queden tareas pendientes.
	\item \textbf{Slave:} consumidor de las tareas. Una vez conectado al cluster, es capaz de buscar y ejecutar tareas. Las distintas clases implementadas proponen distintas políticas de robo, las cuales serán detalladas más adelante.
	\item \textbf{Monitor:} interfaz no implementada en su totalidad, pero diseñada para el acceso a la información detallada sobre el cluster. Esta entidad provee una interfaz para obtener datos sobre las tareas y los nodos conectados.
\end{itemize}


Todos los nodos poseen un estado global del cluster, el cual incluye la lista de todos los nodos y su información, a través de la interfaz \textit{NodeInformation}; y los datos básicos pertenecientes a todas las tareas que están trabajando, pendientes o finalizadas a través de la clase \textit{TaskEntry}.

% Imagen de la jerarquía de interfaces de nodos fig:interfacesNodos
\label{fig:interfacesNodos}
%Imagen de la jerarquía de clases de nodos fig:clasesNodos
\label{fig:clasesNodos}

\subsubsection*{Tareas}

Las tareas están provistas como una interfaz contenedora llamada \textit{Task}, cuya ejecución estará a cargo del método \textit{call()}. Estas devolverán un resultado que se podrá acceder a través del \textit{Future} generado por el \textit{Master}. Cualquier tipo de excepción o error será notificado a través del mismo medio.

% Diagrama de secuencia

Como se puede observar en \ref{img:secuenciaTarea}, una vez que se le solicita una tarea al \textit{Master}, este solo notificará a todo el cluster sobre la novedad, pero no enviará la tarea en sí hasta no recibir una solicitud de ejecución de un \textit{Slave}. Una vez enviada la tarea al nodo responsable, solo quedará ejecutarla y devolver el resultado o excepción. Estos estados por los que pasa cada tarea se puede observar en \ref{img:estadosTarea}.

% Estados de una tarea

Las tareas serán ejecutadas en un nodo, el cual será determinado inicialmente por las políticas de scheduling del \textit{Master}, con posibles variaciones debido a los robos. Estas características deberán ser establecidas y desarrolladas por el programador que desee utilizar el sistema.

Cabe destacar que también se ha implementado una subclase especial de tarea, la cual permite que la misma se pause ante necesidades especiales del \textit{Slave}. De todas formas, hasta el momento el sistema no aprovecha esta característica.

\subsubsection*{Mensajes}

Internos al sistema y completamente transparente, los datos enviados a través del cluster son realizados a través del paquete de clases de \textit{Message}. Existen distintos tipos de mensajes, los cuales se muestran en \ref{img:mensajes}.

\subsubsection*{Políticas}

Tanto el scheduling inicial del \textit{Master} como la elección de víctimas del \textit{Slave} que roba necesitará una política determinada. Mediante el patrón de diseño \textbf{Strategy}, las políticas podrán ser definidas por el programador y cambiadas en tiempo de ejecución. Los tipos de política son:

\begin{itemize}
	\item \textbf{SchedulingStrategy:} Utilizado por el \textit{Master} y ejecutado cada vez que se inserte una nueva tarea al cluster, el algoritmo de scheduling deberá determinar un nodo que ejecute la nueva tarea en base a información sobre estos.
	\item \textbf{StealingStrategy:} cuando un \textit{Slave} termina sus tareas, puede aplicar un algoritmo para seleccionar una tarea o nodo como víctima. La información utilizada por estas políticas será información sobre nodos o tareas. 
Se debe aclarar que si no se define políticas de robo, el \textit{Slave} nunca robará, convirtiéndose así en un consumidor reactivo.
\end{itemize}

La forma de utilizar las políticas será detallada en la sección \ref{sec:util}

\subsubsection*{Eventos}

Los nodos informarán cambios en los estados de las tareas y del cluster en general a través de la interfaz \textit{Eventable}, la cual podrá ser utilizada si se requiere adquirir información detallada.


\subsection*{Utilización y aplicaciones}
\label{sec:util}

Para poder utilizar este sistema se deberá tener en cuenta ciertos aspectos, los cuales permitirán el desarrollo de un sistema grid personalizable en cuanto a topología, comunicación y scheduling y robo de tareas.


\subsection*{Historial de cambios}%

\end{document}